Singleton Design Pattern
AmaÃ§: Bir sÄ±nÄ±fÄ±n yalnÄ±zca bir Ã¶rneÄŸi (instance) olmasÄ±nÄ± saÄŸlamak ve bu Ã¶rneÄŸe evrensel bir eriÅŸim noktasÄ± sunmak.

ğŸ¯ Nerede KullanÄ±lÄ±r?
Database baÄŸlantÄ±sÄ± (tek baÄŸlantÄ± noktasÄ±)

Logger (tek loglama servisi)

KonfigÃ¼rasyon ayarlarÄ± (global ayarlar)

Thread pool, cache yÃ¶neticisi gibi sistem kaynaklarÄ±

DÃ¼ÅŸÃ¼nsene her loglama iÅŸleminde yeni bir logger nesnesi oluÅŸturuyorsun:

Bu hem kaynak israfÄ± hem de tutarsÄ±zlÄ±k demek. Logger tÃ¼m uygulama boyunca aynÄ± nesne olmalÄ±.

Dikkat Edilmesi Gerekenler:
Ã‡oklu thread ortamÄ±nda gÃ¼venli deÄŸilse synchronized kullanmak gerekebilir.

Lazy (ihtiyaÃ§ anÄ±nda yaratÄ±lan) ya da eager (baÅŸta yaratÄ±lan) olabilir.

Thread-Safe Singleton
Problem:
Ã‡oklu thread ortamÄ±nda (Ã¶zellikle web uygulamalarÄ±, servisler gibi Ã§ok kullanÄ±cÄ±lÄ± yapÄ±larda) birden fazla thread aynÄ±
 anda getInstance() metodunu Ã§aÄŸÄ±rÄ±rsa, birden fazla Singleton nesnesi oluÅŸabilir. Bu da Singleton mantÄ±ÄŸÄ±nÄ± bozar.


 Riskli Durum Ã–rneÄŸi:
java
Kopyala
DÃ¼zenle
if (instance == null) {
    instance = new Singleton(); // iki thread aynÄ± anda buraya girebilir
}
âœ… Ã‡Ã¶zÃ¼m 1: synchronized ile Method Kilitleme
java
Kopyala
DÃ¼zenle
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
ğŸ’¡ ArtÄ±: Kolay ve gÃ¼venli
ğŸ˜• Eksi: Her Ã§aÄŸrÄ±da kilitlenir, performansÄ± biraz dÃ¼ÅŸÃ¼rÃ¼r

âœ… Ã‡Ã¶zÃ¼m 2: Double-Checked Locking
java
Kopyala
DÃ¼zenle
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) { // birinci kontrol
            synchronized (Singleton.class) {
                if (instance == null) { // ikinci kontrol
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
ğŸ’¡ ArtÄ±: Sadece ilk yaratÄ±mda kilit kullanÄ±lÄ±r
âš ï¸ volatile olmazsa JVM optimizasyonlarÄ± problemi doÄŸurabilir

âœ… Ã‡Ã¶zÃ¼m 3: Eager Initialization (Tembel Olmayan)
java
Kopyala
DÃ¼zenle
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
ğŸ’¡ ArtÄ±: Ã‡ok basit ve thread-safe
ğŸ˜• Eksi: Uygulama baÅŸlarken hemen oluÅŸur, her zaman ihtiyaÃ§ olmayabilir

âœ… Ã‡Ã¶zÃ¼m 4: Static Inner Class (En Temiz Ã‡Ã¶zÃ¼m)
java
Kopyala
DÃ¼zenle
public class Singleton {

    private Singleton() {}

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
ğŸ’¡ AvantajÄ±:

Lazy (ihtiyaÃ§ olunca oluÅŸturur)

Thread-safe

PerformansÄ± yÃ¼ksek

Bu Ã§Ã¶zÃ¼mlerden uygulamana gÃ¶re en uygun olanÄ± seÃ§ebilirsin.
Javaâ€™da genelde static inner class yÃ¶ntemi tercih edilir Ã§Ã¼nkÃ¼ sade ve gÃ¼venlidir.
